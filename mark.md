# 前言

该文章只是对于《C++ and the Perils of Double-Checked Locking》这篇论文的全文翻译加上一些我写的鬼话，论文作者就是我们 C++ 程序员所熟知的 Scott Meyers 和 Andrei Alexandrescu，他们真的有很多好的作品，即使有一些跟不上时代了，但一定比某些华而不实的走量不走心的教程好，推荐阅读学习。需要注意的是这篇论文创作于 2004 年，有一些设施在 C++11 或更新的 C++ 版本中或许已经司空见惯，但当时确实是不存在于标准当中的，带着这种想法阅读本文，一定可以体验到编程的有趣。

当然，开头第一句引言就很有意思：Multithreading is just one damn thing after, before, or simultaneous with another. 自己翻译一下吧

# 描述

在网络上搜索各种设计模式，你肯定会发现最常提到的一种是 `Singleton`。然而，尝试将 `Singleton` 付诸实践，你包会遇到一个常见的问题：按照传统实现方式（我们将在下面解释），`Singleton` 不是线程安全的。

人们付出了很多努力来解决这一缺陷。其中最流行的方法之一就是双重检查锁定模式 (DCLP)。DCLP 旨在为共享资源（如单例）的初始化添加有效的线程安全性，但它有一个问题：它不可靠。此外，在不大幅修改传统模式实现的情况下，几乎没有任何可移植的方法可以在 C++（或 C 语言）中使其可靠。更有趣的是，DCLP 可能会因不同的原因在单处理器和多处理器架构上失败。所以面试的时候尽量避免说双检锁实现 `Singleton` 或者说清楚错误的原因。

本文解释了 `Singleton` 为何不是线程安全的，DCLP 如何尝试解决该问题，DCLP 为何在单处理器和多处理器架构上都可能失败，以及为什么您无法（可移植地）对此采取任何措施。在此过程中，它阐明了源代码中的语句顺序、序列点、编译器和硬件优化以及语句执行的实际顺序之间的关系。最后，它总结了一些关于如何向 Singleton（和类似构造）添加线程安全性的建议，以使生成的代码既可靠又高效。

# 2 单例模式和多线程

单例模式的传统实现是在第一次请求对象时让指针指向一个新对象：

*这是 2004 年 7 月（第一部分）和 8 月（第二部分）《Dr. Dobbs Journal》上发表的一篇文章的略微修改版本*

```cpp
// from the header file
class Singleton {
public:
    static Singleton* instance();
    ...
private:
    static Singleton*pInstance;
};

// from the implementation file
Singleton* Singleton::pInstance = 0;

Singleton* Singleton::instance(){
    if(pInstance==0){
        pInstance=new Singleton;
    }
    return pInstance;
}
```

在单线程环境中，这通常可以正常工作，但如果触发中断可能会有问题。如果您在 `Singleton::instance` 中，收到中断，并从处理程序调用 `Singleton::instance`，您就可以看到自己会遇到什么样的麻烦。

然而，除了中断之外，此实现在单线程环境中工作正常，但不幸的是，这种实现在**多线程环境下并不可靠**。假设线程 A 进入实例函数，执行到第 14 行 `if(pInstance == 0)`，然后被挂起。在被挂起的地方，它刚刚确定 `pInstance` 为 `null`，即尚未创建任何 `Singleton` 对象。线程 B 现在进入实例并执行第 14 行。它看到 `pInstance` 为空，因此继续执行第 15 行并创建一个供 `pInstance` 指向的单例。然后它将 `pInstance` 返回给实例的调用，稍后，线程 A 被允许继续运行，它做的第一件事就是移动到第 15 行，在那里它召唤出另一个 `Singleton` 对象并让 `pInstance` 指向它。很明显，这违反了单例的含义，因为现在有两个 `Singleton` 对象。从技术上讲，第 11 行 `Singleton* Singleton::pInstance = 0` 是 `pInstance` 初始化的地方，但从实际目的来看，第 15 行 `pInstance = new Singleton;` 才是让它指向我们想要的位置，因此在本文的其余部分，我们将第 15 行视为 `pInstance` 初始化的位置。让经典的 `Singleton` 实现线程安全很容易。只需在检测 `pInstance` 之前获取一个锁即可：

```cpp
Singleton* Singleton::instance(){
    Lock lock;     // acquire lock (params omitted for simplicity)
    if(pInstance == 0){
        pInstance = new Singleton;
    }
    return pInstance; 
}        // release lock (via Lock destructor)
```

这种解决方案的缺点是它可能很开销很大。每次访问 `Singleton` 都需要获取锁(我们简化了锁的写法，这里如果不想手动 `unlock` 的话可以使用 `lock_gurd`)，但实际上，我们仅在初始化 `pInstance` 时才需要锁。这应该只在第一次调用 `instance` 时发生。如果在程序运行过程中调用了 `n` 次 `instance` ，我们只需要在第一次调用时获取锁。既然您知道其中 `n - 1` 次是不必要的，为什么还要为 `n` 次锁付出额外的开销呢？DCLP 旨在防止您这样做。

# 3 DCLP

DCLP 的关键在于我们发现大多数对实例的调用都会得出 **`pInstance` 不为空**，因此甚至不会尝试初始化它。因此，DCLP 在尝试获取锁之前会检测 `pInstance` 是否为空。**只有检测成功（即，如果 `pInstance` 尚未初始化）才会获取锁**，之后会再次执行测试以确保 `pInstance` 仍为空（因此称为双重检查锁定）。第二个测试是必要的，因为正如我们刚刚看到的，在第一次测试 `pInstance` 和获取锁之间，可能恰好有另一个线程初始化了 `pInstance`。

以下是经典的 DCLP 实现：

```cpp
Singleton* Singleton::instance(){
    if(pInstance==0){    // 1st test
        Lock lock;
    if(pInstance ==0){    // 2nd test
        pInstance=new Singleton;
    }
    return pInstance,
```

定义 DCLP 讨论了一些实现问题（例如，对单例指针进行 `volatile` 限定的重要性以及单独缓存对多处理器系统的影响，我们将在下文中讨论这些问题；以及确保某些读写的原子性的必要性，我们在本文中不讨论这些问题），但它们没有考虑一个更基本的问题，即**确保在 DCLP 期间执行的机器指令以可接受的顺序执行**(人话就是要考虑指令重排引发的问题)。

# 4 DCLP 和 指令重排

再次考虑初始化 pInstance 的那一行：

```cpp
pInstance = new Singleton;
```

接下来的话引起重视，**此语句会导致三件事发生**：1. 分配内存以保存 `Singleton` 对象。2. 在分配的内存中构造 `Singleton` 对象。3. 使 `pInstance` 指向分配的内存。

**至关重要的是，编译器并不一定要按此顺序执行这些步骤！** 具体来说，编译器有时可以交换步骤 2 和步骤 3。“为什么它们会这样做”，别急我们稍后会回答这个问题。现在，让我们关注一下如果它们这样做会发生什么？

考虑以下代码，我们将 `pInstance` 的初始化行详细扩展为上面提到的三个组成任务，并将步骤 1（内存分配）和步骤 3（`pInstance` 赋值）合并为一个位于步骤 2（单例构造）之前的语句。我们的想法其实不是人类会编写的代码。相反，而是编译器可能会生成与此等效的代码，以响应人类编写的传统 DCLP 源代码（如前所示），对，我知道这很抽象。

```cpp
Singleton* Singleton::instance(){
    if(pInstance == 0){
        Lock lock;
        if(pInstance == 0){
            pInstance =                             // Step 3------->合
                operator new(sizeof(Singleton));    // Step 1------->并
            new(pInstance) Singleton;               // Step 2
        }
    }
    return pInstance;
}
```

一般来说，这不是原始 DCLP 源代码的有效转换，因为步骤 2 中调用的 `Singleton` 构造函数可能会抛出异常，如果抛出异常，则重要的是 `pInstance` 尚未被修改。这就是为什么编译器**不能**将步骤 3 移到步骤 2 之上。但是，在某些情况下，这种转换是合法的。也许最简单的条件是编译器可以证明 `Singleton` 构造函数不能抛出异常（例如，通过[后内联流分析](#后内联流分析)），但这不是唯一的条件。一些抛出的构造函数也可能使其指令重新排序，从而出现此问题。

根据上述解释，考虑以下事件序列：

- 线程A进入 `instance`，对 `pInstance `进行第一次测试，获取锁，执行步骤 1 和 3 的语句，然后被挂起，此时 `pInstance` 不为 `null`，但是 `pInstance `指向的内存中还没有构造 `Singleton` 对象。
- 线程 B 进入实例，确定 `pInstance` 非空，并将其返回给实例的调用者。然后，调用者取消引用指针以访问尚未构造的 `Singleton`。

只有在步骤 3 之前完成步骤 1 和 2 时，DCLP 才会起作用，**但是没有办法用 C 或 C++ 表达这种约束**。这就是 DCLP 的致命弱点：我们需要定义相对指令顺序的约束，但我们的语言没有办法表达这种约束。是的，C 和 C++ 标准确实定义了序列点，它定义了对求值顺序的约束。例如，C++ 标准第 1.9 节第 7 段指出：

> At certain specified points in the execution sequence called sequence points, all side effects of previous evaluations shall be complete and no side effects of subsequent evaluations shall have taken place.

> 在执行序列中的某些指定点（称为序列点）处，先前评估的所有副作用都应完成，并且后续评估的任何副作用都应未发生。

此外，两个标准都规定，序列点出现在每个语句的末尾。因此，只要小心谨慎地对语句进行排序，一切就都水到渠成了。这两个标准都根据抽象机器的可观察行为来定义正确的程序行为。但并非有关该机器的所有事情都是可观察的。例如，考虑这个简单的函数：

```cpp
void Foo(){
    int x = 0, y = 0;            // Statement 1
    x = 5;                       // Statement 2
    y = 10;                      // Statement 3
    printf("%d, %d", x, y);      // Statement 4
}
```

这个函数看起来很呆，但它可能是内联 `Foo` 调用的一些其他函数的结果。

在 C 和 C++ 中，标准都保证 `Foo` 将打印“5, 10”，因此我们知道这会发生。但这就是我们所保证的程度，因此也是我们所知道的程度。我们不知道语句 1-3 是否会被执行，事实上，一个好的优化器会摆脱它们。如果执行了语句 1-3，我们知道语句 1 将先于语句 2-4，并且假设对 `printf` 的调用未内联且结果进一步优化，我们知道语句 4 将跟在语句 1-3 之后，但我们对语句 2 和 3 的相对顺序一无所知。编译器可能会选择先执行语句 2，先执行语句 3，甚至并行执行它们？假设硬件有某种方式来做到并行这一点。

> 它是很有可能的。现代处理器具有很大的字长和多个执行单元。两个或更多的算术单元很常见。 （例如，`Pentium` 4 有三个整数 `ALU`，`PowerPC` 的 `G4e` 有四个，而 `Itanium` 有六个。）它们的机器语言允许编译器生成在单个时钟周期内并行执行两个或多个指令的代码。

优化编译器会仔细分析并重新排序代码，以便尽可能多地同时执行任务（在可观察行为的限制范围内）。在常规串行代码中发现和利用这种并行性是重新排列代码吗，并引入乱序执行的最重要原因。但这不是唯一的原因。编译器（和链接器）也可能重新排序指令，以避免溢出寄存器中的数据，保持指令流水线满载，执行公共子表达式消除，并减少生成的可执行文件的大小等等等等（编译器所做的优化太多了，我也不是很懂啊啊啊啊啊啊啊啊）。

在执行这些类型的优化时，C 和 C++ 的编译器和链接器仅受语言标准定义的抽象机器上可观察行为的约束，这一点很重要，这些抽象机器是隐式单线程的。**作为语言，C 和 C++ 都没有线程，因此编译器在优化时不必担心破坏线程程序**。希望你们可以理解这段话，因此，有时它们会破坏线程程序，这应该并不奇怪。

既然如此，如何编写真正能运行的 C 和 C++ 多线程程序呢？使用为此目的定义的系统特定库。像 `Posix` 线程 (pthreads)这样的库为各种同步原语的执行语义提供了精确的规范。这些库对符合库要求的编译器可以生成的代码施加了限制，从而迫使这些编译器生成遵守这些库所依赖的执行顺序约束的代码。这就是为什么线程包中有部分是用汇编语言编写的，或者发出用汇编语言（或某种不可移植的语言）编写的系统调用的原因：您必须超越标准 C 和 C++ 来表达多线程程序所需的顺序约束。DCLP 试图仅使用语言结构来实现，从逻辑的角度来说就是站不住脚的。这就是 DCLP 不可靠的原因。

一般来说，程序员不喜欢被编译器摆布。也许吧你就是这样的程序员。如果是这样，你可能会试图通过调整源代码来越过一些编译器优化，使 `pInstance` 保持不变，直到 `Singleton` 的构造完成。想想一些有趣吧办法，例如，你可以尝试插入临时变量的使用：

```cpp
Singleton* Singleton::instance(){
    if(pInstance == 0){
        Lock lock;
        if(pInstance == 0){
            Singleton* temp = new Singleton;    // initialize to temp
            pInstance = temp;                   // assign temp to pInstance
        }
    }
    return pInstance;
}
```

相信到这里你来感觉了，因为这触及到了编译器的优化战争，是程序员和编译器之间的交互，让你自己真正有了能控制编译器作为得出自己想要的结果的工具的想法。（原谅我有点抽象）。你的编译器想要优化，但你不希望它优化，至少在这里不希望。但这不是你想卷入的战斗。*你的敌人狡猾而老练，他们满脑子都是几十年来那些整天、日复一日、年复一年思考这类事情的人想出的战略。除非你自己编写优化编译器，否则他们远远领先于你*

哈哈，其实在这种情况下，对于编译器来说，它会应用依赖性分析来确定 `temp` 是一个不必要的变量，从而将其消除，对于编译器来说这是一件很简单的事情，你的想法就像你精心编写的“不可优化”的代码一样，在顶尖程序员所贡献的编译器面前不堪一击，游戏结束。你输了。如果您再狠一点并尝试将 `temp` 移至更大的范围（例如将其设为静态文件），编译器仍然可以执行相同的分析并得出相同的结论。范围(scope)，傻瓜(schmope)。你又输了。

所以呢你请求一个备份，无所不用其极，声明 `temp extern` 并在单独的翻译单元中定义它，从而阻止你的编译器看到你正在做的事情。遗憾的是，有些编译器有“透视眼”的优化功能：它们执行过程间分析，发现你使用 `temp` 的诡计，然后再次优化它以使其不复存在。请记住，这些都是编译器优化。它们被设计就是应该用来追踪不必要的代码并将其消除，在绝大多数情况下这是利好程序员的。好嘛游戏结束。你又又输了。

因此，您尝试通过在另一个文件中定义辅助函数来禁用内联，从而迫使编译器假设构造函数可能会引发异常，因此延迟对 `pInstance` 的赋值，能想到这里的都不是泛泛之辈了。不错的尝试，但某些构建环境会执行**链接时内联**，然后进行更多代码优化。**游戏结束。你又又又输了**。

您所做的一切都无法改变根本问题：您需要能够指定指令排序的约束，但您的语言却无法做到这一点（本论文作者作于2004年，当时在 C++ 语言层面并没有实现如 `atomic`之类的操作，内存序也是C++11提出的）。

# 5 几乎成名，volatile 关键字














## 后内联流分析

后内联流分析（Post-Inlining Flow Analysis）是一种在程序优化中使用的技术，主要用于提高编译器对代码行为的理解，尤其是在函数内联之后。这种分析通常在编译器的中间表示（IR）阶段进行，用于评估程序的控制流和数据流。








